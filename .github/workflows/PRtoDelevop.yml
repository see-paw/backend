name: CI - Tests And Inspection

on:
  pull_request:
    branches: [ "develop" ] # executa quando hÃ¡ PR para a dev
    paths-ignore:
       - '.github/workflows/**'

env:
  DOTNET_VERSION: "8.0.x"
  ASPNETCORE_ENVIRONMENT: "Test"

jobs:
  # ======================================================
  # 1ï¸âƒ£ BUILD JOB
  # ======================================================
  build:
    runs-on: ubuntu-latest
    environment: Test
    container:
      image: mcr.microsoft.com/dotnet/sdk:8.0

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Cache do NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restaurar dependÃªncias
        run: dotnet restore SeePaw.sln

      - name: Compilar projeto
        run: dotnet build SeePaw.sln --no-restore --configuration Release

      - name: Guardar artefactos do build
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            **/bin/Release/
            **/obj/Release/

  # ======================================================
  # 2ï¸âƒ£ UNIT TESTS
  # ======================================================
  unit_tests:
    runs-on: ubuntu-latest
    environment: Test
    container:
      image: mcr.microsoft.com/dotnet/sdk:8.0
    needs: build

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4
        
      - name: Descarregar artefactos
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ./
          
      - name: Restaurar dependÃªncias dos testes
        run: dotnet restore Tests/Tests.csproj

      - name: Correr testes unitÃ¡rios (xUnit) + Cobertura
        run: |
         mkdir -p TestResults

          echo "ğŸ§ª A testar: Tests/Tests.csproj"
          
          # Correr testes com cobertura em formato OpenCover
          dotnet test Tests/Tests.csproj \
            --no-restore \
            --configuration Release \
            --logger "trx;LogFileName=test-results.trx" \
            --results-directory TestResults \
            --collect:"XPlat Code Coverage" \
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover
          
          echo ""
          echo "âœ… Testes concluÃ­dos"
          echo ""
          
          # Encontrar e copiar ficheiro de cobertura
          echo "ğŸ” Procurando ficheiros de cobertura OpenCover..."
          coverage_file=$(find TestResults -name "coverage.opencover.xml" -type f | head -1)
          
          if [ -n "$coverage_file" ]; then
            cp "$coverage_file" TestResults/coverage.xml
            echo "âœ… Cobertura encontrada: $coverage_file"
            echo "âœ… Copiada para: TestResults/coverage.xml"
          else
            echo "âš ï¸ AVISO: Ficheiro de cobertura OpenCover nÃ£o encontrado!"
            echo "ğŸ” Procurando outros formatos..."
            find TestResults -name "*.xml" -type f
          fi
          
          echo ""
          echo "ğŸ“‚ Ficheiros finais em TestResults:"
          ls -lah TestResults/
          echo ""
          echo "ğŸ“‚ Estrutura completa:"
          find TestResults -type f
            
      - name: Mostrar resumo dos testes
        if: always()
        run: |
          if [ -f TestResults/test-results.trx ]; then
            echo "âœ… Testes executados com sucesso"
            
            passed=$(grep -o 'outcome="Passed"' TestResults/test-results.trx | wc -l || echo "0")
            failed=$(grep -o 'outcome="Failed"' TestResults/test-results.trx | wc -l || echo "0")
            total=$((passed + failed))
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“Š RESUMO DOS TESTES UNITÃRIOS"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "   Total: $total"
            echo "   âœ… Passaram: $passed"
            echo "   âŒ Falharam: $failed"
            
            if [ $failed -eq 0 ] && [ $total -gt 0 ]; then
              echo "   ğŸ‰ Todos os testes passaram!"
            elif [ $failed -gt 0 ]; then
              echo "   âš ï¸  Alguns testes falharam"
            fi
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          fi

      - name: Exportar resultados de testes
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: |
            TestResults/*.trx
            TestResults/*.xml
          if-no-files-found: warn

  # ======================================================
  # 3ï¸âƒ£ INTEGRATION TESTS
  # ======================================================
  integration_tests:
    runs-on: ubuntu-latest
    environment: Test
    needs: build

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: seepaw
          POSTGRES_PASSWORD: seepaw
          POSTGRES_DB: seepaw_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U seepaw -d seepaw_test"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20

    env:
      ASPNETCORE_ENVIRONMENT: Docker
      ConnectionStrings__DefaultConnection: "Host=localhost;Port=5432;Database=seepaw_test;Username=seepaw;Password=seepaw"

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4
        
      - name: Descarregar artefactos do build
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ./


      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restaurar dependÃªncias
        run: dotnet restore SeePaw.sln

      - name: Compilar projeto
        run: dotnet build SeePaw.sln --no-restore --configuration Release

      - name: Iniciar API em background
        run: |
          echo "ğŸš€ A iniciar a API..."
          dotnet run --project API/API.csproj --configuration Release --no-build --urls "http://0.0.0.0:5000" &
          echo $! > server_pid.txt
          echo "â³ A aguardar que a API fique pronta..."
          timeout 60 bash -c '
             until nc -z localhost 5000; do
              echo "Aguardando..."
              sleep 3
          done
          ' || (echo "âŒ A API nÃ£o respondeu a tempo" && exit 1)
          echo "âœ… API pronta!"

      - name: Executar testes Postman (todas as coleÃ§Ãµes da API)
        run: |
          set -e
          
          echo "ğŸ” A obter todas as coleÃ§Ãµes do Postman..."
          
          API_KEY="${{ secrets.POSTMAN_API_KEY }}"
          ENV_ID="${{ secrets.POSTMAN_ENV_ID }}"
          
          mkdir -p TestResults
          
          # Pre-pull da imagem Newman
          echo "ğŸ“¦ A preparar imagem Newman..."
          docker pull postman/newman:latest > /dev/null 2>&1
          
          # Obter todas as coleÃ§Ãµes
          echo "ğŸ“¡ A fazer pedido Ã  API do Postman..."
          collections_json=$(curl -s "https://api.getpostman.com/collections" \
            -H "X-Api-Key: $API_KEY")
          
          collection_uids=$(echo "$collections_json" | jq -r '.collections[].uid')
          
          if [ -z "$collection_uids" ]; then
            echo "âŒ Nenhuma coleÃ§Ã£o encontrada!"
            exit 1
          fi
          
          total_collections=$(echo "$collection_uids" | wc -l)
          echo "ğŸ“‹ Total de coleÃ§Ãµes encontradas: $total_collections"
          echo ""
          
          # Inicializar contadores
          executed=0
          skipped=0
          skipped_no_tests=0
          total_assertions=0
          passed_assertions=0
          failed_assertions=0
          
          collection_number=0
          while IFS= read -r col_uid; do
            collection_number=$((collection_number + 1))
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ ColeÃ§Ã£o $collection_number/$total_collections"
            echo "ğŸ†” UID: $col_uid"
            
            # Obter detalhes da coleÃ§Ã£o
            echo "ğŸ” A verificar detalhes..."
            col_details=$(curl -s "https://api.getpostman.com/collections/$col_uid" \
              -H "X-Api-Key: $API_KEY")
            
            col_name=$(echo "$col_details" | jq -r '.collection.info.name // "Desconhecido"')
            echo "ğŸ“ Nome: $col_name"
            
            # Verificar se tem items
            items_count=$(echo "$col_details" | jq '[.collection.item[]?] | length')
            
            if [ "$items_count" = "0" ] || [ "$items_count" = "null" ]; then
              echo "â­ï¸  SKIP: ColeÃ§Ã£o vazia (sem items)"
              skipped=$((skipped + 1))
              echo ""
              continue
            fi
            
            # Contar requests vÃ¡lidos (com URL nÃ£o vazia)
            valid_requests=$(echo "$col_details" | jq '
              def has_valid_url:
                .url != null and 
                .url != "" and 
                .url != {} and
                (.url | type) != "null" and
                (if (.url | type) == "string" then .url != "" 
                 elif (.url | type) == "object" then (.url.raw // "" | . != "")
                 else false end);
              
              [.. | select(.request?) | .request | select(has_valid_url)] | length
            ')
            
            if [ "$valid_requests" = "0" ] || [ "$valid_requests" = "null" ]; then
              echo "â­ï¸  SKIP: Sem requests vÃ¡lidos ($items_count items, mas sem URLs)"
              skipped=$((skipped + 1))
              echo ""
              continue
            fi
            
            # Contar quantos requests tÃªm testes (assertions)
            requests_with_tests=$(echo "$col_details" | jq '
              [.. | select(.request?) | select(.event[]?.listen == "test")] | length
            ')
            
            echo "âœ… VÃ¡lida: $valid_requests requests"
            if [ "$requests_with_tests" = "0" ] || [ "$requests_with_tests" = "null" ]; then
              echo "âš ï¸  Aviso: Nenhum request tem testes definidos"
            else
              echo "ğŸ§ª $requests_with_tests requests com testes"
            fi
            
            echo "ğŸš€ A executar..."
            
            # Executar Newman
            safe_name=$(echo "$col_name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
            
            set +e
            docker run --rm \
              --network host \
              -v "$PWD/TestResults:/etc/newman" \
              postman/newman:latest \
              run "https://api.getpostman.com/collections/$col_uid?apikey=$API_KEY" \
              --environment "https://api.getpostman.com/environments/$ENV_ID?apikey=$API_KEY" \
              --env-var "url=http://localhost:5000" \
              --reporters cli,json,junit \
              --reporter-json-export "/etc/newman/result-${safe_name}.json" \
              --reporter-junit-export "/etc/newman/junit-${safe_name}.xml" \
              --suppress-exit-code \
              --color on \
              --delay-request 300 \
              --timeout-request 10000 \
              --bail false \
              2>&1 | tee "TestResults/log-${safe_name}.txt"
            
            set -e
            
            # Processar resultados do JSON
            result_file="TestResults/result-${safe_name}.json"
            if [ -f "$result_file" ]; then
              # Ler estatÃ­sticas do Newman
              col_assertions=$(jq -r '.run.stats.assertions.total // 0' "$result_file")
              col_assert_failed=$(jq -r '.run.stats.assertions.failed // 0' "$result_file")
              
              # CALCULAR passaram (total - falharam)
              col_assert_passed=$((col_assertions - col_assert_failed))
              
              # Debug: mostrar o que foi lido
              echo "ğŸ” Debug: total=$col_assertions, failed=$col_assert_failed, calculated_passed=$col_assert_passed"
              
              # Se nÃ£o tem assertions, marcar como "executada mas sem testes"
              if [ "$col_assertions" = "0" ]; then
                echo "â„¹ï¸  Executada: 0 testes (coleÃ§Ã£o sem assertions)"
                skipped_no_tests=$((skipped_no_tests + 1))
              else
                executed=$((executed + 1))
                
                # Acumular totais
                total_assertions=$((total_assertions + col_assertions))
                passed_assertions=$((passed_assertions + col_assert_passed))
                failed_assertions=$((failed_assertions + col_assert_failed))
                
                # Mostrar resultados
                if [ "$col_assert_failed" -gt 0 ]; then
                  echo "âŒ Testes: $col_assert_passed/$col_assertions passaram ($col_assert_failed falharam)"
                else
                  echo "âœ… Testes: $col_assert_passed/$col_assertions passaram"
                fi
              fi
            else
              echo "âš ï¸  Sem relatÃ³rio JSON gerado"
              skipped=$((skipped + 1))
            fi
            
            echo ""
            
          done <<< "$collection_uids"
          
          # Resumo final
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š RESUMO FINAL"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ ColeÃ§Ãµes:"
          echo "   Total analisadas: $total_collections"
          echo "   âœ… Com testes executados: $executed"
          echo "   â„¹ï¸  Sem testes (mas processadas): $skipped_no_tests"
          echo "   â­ï¸  Ignoradas (vazias/invÃ¡lidas): $skipped"
          echo ""
          echo "ğŸ§ª TESTES (Assertions):"
          echo "   Total de testes: $total_assertions"
          echo "   âœ… Passaram: $passed_assertions"
          echo "   âŒ Falharam: $failed_assertions"
          
          if [ $total_assertions -gt 0 ]; then
            success_rate=$(awk "BEGIN {printf \"%.1f\", ($passed_assertions/$total_assertions)*100}")
            echo "   ğŸ“ˆ Taxa de sucesso: ${success_rate}%"
            echo ""
            
            # Detalhes para contexto
            if [ $passed_assertions -eq $total_assertions ]; then
              echo "ğŸ‰ Resultado: TODOS OS TESTES PASSARAM!"
            elif [ $passed_assertions -eq 0 ]; then
              echo "âš ï¸  Resultado: NENHUM TESTE PASSOU"
            else
              echo "âš ï¸  Resultado: ALGUNS TESTES FALHARAM ($passed_assertions/$total_assertions passaram)"
            fi
          else
            echo ""
            echo "â„¹ï¸  Nenhum teste (assertion) foi encontrado nas coleÃ§Ãµes"
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Gerar relatÃ³rio para SonarCloud
          if [ $total_assertions -gt 0 ]; then
            success_rate=$(awk "BEGIN {printf \"%.2f\", ($passed_assertions/$total_assertions)*100}")
          else
            success_rate=0
          fi
          
          cat > TestResults/newman-summary.json <<EOF
          {
            "summary": {
              "collections": {
                "total": $total_collections,
                "withTests": $executed,
                "withoutTests": $skipped_no_tests,
                "skipped": $skipped
              },
              "tests": {
                "total": $total_assertions,
                "passed": $passed_assertions,
                "failed": $failed_assertions,
                "successRate": $success_rate
              }
            },
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": $([ $total_assertions -eq 0 ] && echo '"NO_TESTS"' || ([ $failed_assertions -eq 0 ] && echo '"PASS"' || echo '"FAIL"'))
          }
          EOF
          
          echo ""
          
          # Mensagem final
          if [ $total_assertions -eq 0 ]; then
            echo "â„¹ï¸  Pipeline continua: Nenhum teste foi executado"
          elif [ $failed_assertions -gt 0 ]; then
            echo "âš ï¸  Pipeline continua: $failed_assertions de $total_assertions testes falharam ($passed_assertions passaram)"
          else
            echo "âœ… Pipeline continua: Todos os $total_assertions testes passaram!"
          fi
    
      
      - name: Upload resultados de integraÃ§Ã£o
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            TestResults/*.json
            TestResults/*.xml
            TestResults/*.txt
            TestResults/newman-summary.json
          if-no-files-found: warn

      - name: Parar API e containers
        if: always()
        run: |
          echo "ğŸ§¹ A encerrar ambiente de teste..."
          kill $(cat server_pid.txt) || true

  # ======================================================
  # 4ï¸âƒ£ QUALITY GATE (SonarCloud)
  # ======================================================
  quality_gate:
    runs-on: ubuntu-latest
    environment: Test
    needs: [unit_tests, integration_tests]

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download resultados de testes
        uses: actions/download-artifact@v4
        with:
          name: integration-test-results
          path: TestResults/integration/
          
      - name: Download resultados de testes
        uses: actions/download-artifact@v4
        with:
          name: unit-test-results
          path: TestResults/unit/

      - name: Debug - Listar artefactos recebidos
        run: |
          echo "ğŸ“‚ ConteÃºdo de TestResults/unit:"
          ls -lah TestResults/unit/ || echo "Pasta nÃ£o existe"
          echo ""
          echo "ğŸ“‚ ConteÃºdo de TestResults/integration:"
          ls -lah TestResults/integration/ || echo "Pasta nÃ£o existe"
          echo ""
          echo "ğŸ” Procurando ficheiros XML recursivamente:"
          find TestResults -type f -name "*.xml" || echo "Nenhum XML encontrado"
          echo ""
          echo "ğŸ” Procurando ficheiros TRX recursivamente:"
          find TestResults -type f -name "*.trx" || echo "Nenhum TRX encontrado"
          
      - name: Validar existÃªncia dos artefactos
        run: |
          echo "ğŸ” Verificando artefactos..."

          if [ ! -d TestResults/unit ]; then
            echo "âŒ Pasta TestResults/unit nÃ£o encontrada"
            exit 1
          fi
          
          if [ ! -d TestResults/integration ]; then
            echo "âŒ Pasta TestResults/integration nÃ£o encontrada"
            exit 1
          fi
          
          if ! ls TestResults/unit/*.trx >/dev/null 2>&1; then
            echo "âŒ Ficheiro .trx de testes unitÃ¡rios nÃ£o encontrado"
            exit 1
          fi
          
          if ! ls TestResults/unit/*.xml >/dev/null 2>&1; then
            echo "âŒ Ficheiro XML de cobertura nÃ£o encontrado"
            exit 1
          fi
          
          echo "âœ… Todos os artefactos encontrados"
     # ==========================================
    # QUALITY GATE 1: Validar Testes UnitÃ¡rios
    # ==========================================
      - name: Quality Gate 1 - Validar Testes UnitÃ¡rios
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š QUALITY GATE 1: TESTES UNITÃRIOS"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          trx_file=$(find TestResults/unit -name "*.trx" | head -1)
          
          if [ -z "$trx_file" ]; then
            echo "âŒ Ficheiro TRX nÃ£o encontrado"
            exit 1
          fi
          
          passed=$(grep -o 'outcome="Passed"' "$trx_file" | wc -l || echo "0")
          failed=$(grep -o 'outcome="Failed"' "$trx_file" | wc -l || echo "0")
          total=$((passed + failed))
          
          echo "Total de testes: $total"
          echo "âœ… Passaram: $passed"
          echo "âŒ Falharam: $failed"
          
          if [ $failed -gt 0 ]; then
            echo ""
            echo "âŒ QUALITY GATE FALHOU: $failed teste(s) unitÃ¡rio(s) falharam"
            exit 1
          fi
          
          if [ $total -eq 0 ]; then
            echo ""
            echo "âŒ QUALITY GATE FALHOU: Nenhum teste unitÃ¡rio foi executado"
            exit 1
          fi
          
          echo ""
          echo "âœ… QUALITY GATE PASSOU: Todos os $total testes unitÃ¡rios passaram"

          # ==========================================
      # QUALITY GATE 2: Validar Testes de IntegraÃ§Ã£o
      # ==========================================
      - name: Quality Gate 2 - Validar Testes de IntegraÃ§Ã£o (Postman)
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š QUALITY GATE 2: TESTES DE INTEGRAÃ‡ÃƒO"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          summary_file="TestResults/integration/newman-summary.json"
          
          if [ ! -f "$summary_file" ]; then
            echo "âš ï¸ Ficheiro newman-summary.json nÃ£o encontrado"
            echo "â„¹ï¸ QUALITY GATE PASSOU: Nenhum teste de integraÃ§Ã£o configurado"
            exit 0
          fi
          
          # Instalar jq se necessÃ¡rio
          if ! command -v jq &> /dev/null; then
            sudo apt-get update -qq
            sudo apt-get install -y jq
          fi
          
          total=$(jq -r '.summary.tests.total // 0' "$summary_file")
          passed=$(jq -r '.summary.tests.passed // 0' "$summary_file")
          failed=$(jq -r '.summary.tests.failed // 0' "$summary_file")
          
          echo "Total de testes: $total"
          echo "âœ… Passaram: $passed"
          echo "âŒ Falharam: $failed"
          
          if [ $failed -gt 0 ]; then
            echo ""
            echo "âŒ QUALITY GATE FALHOU: $failed teste(s) de integraÃ§Ã£o falharam"
            exit 1
          fi
          
          if [ $total -eq 0 ]; then
            echo ""
            echo "â„¹ï¸ QUALITY GATE PASSOU: Nenhum teste de integraÃ§Ã£o foi executado"
            exit 0
          fi
          
          echo ""
          echo "âœ… QUALITY GATE PASSOU: Todos os $total testes de integraÃ§Ã£o passaram"


      - name: SonarCloud Scan
        uses: sonarsource/sonarcloud-github-action@v3
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: >
            -Dsonar.organization=see-paw
            -Dsonar.projectKey=see-paw_backend
            -Dsonar.sources=API,Domain,Persistence
            -Dsonar.tests=Tests
            -Dsonar.cs.opencover.reportsPaths=TestResults/unit/coverage.xml
            -Dsonar.coverage.exclusions=**/Migrations/**,**/Program.cs
            -Dsonar.exclusions=**/Dockerfile,**/Dockerfile.*,**/*.dockerfile
            -Dsonar.qualitygate.wait=true
            
     # ==========================================
    # QUALITY GATE 3: SonarCloud Quality Gate
    # ==========================================
      - name: Quality Gate 3 - Verificar SonarCloud Quality Gate
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š QUALITY GATE 3: SONARCLOUD"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          # Instalar jq se necessÃ¡rio
          if ! command -v jq &> /dev/null; then
            sudo apt-get update -qq
            sudo apt-get install -y jq
          fi
          echo "â³ Aguardando anÃ¡lise do SonarCloud..."
          sleep 15
          
          # CORRETO: Incluir o pullRequest na query
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          if [ -z "$PR_NUMBER" ]; then
            echo "âš ï¸ NÃ£o Ã© um Pull Request, a consultar branch..."
            status=$(curl -s "https://sonarcloud.io/api/qualitygates/project_status?projectKey=see-paw_backend" \
              -H "Authorization: Bearer ${{ secrets.SONAR_TOKEN }}" | jq -r '.projectStatus.status')
          else
            echo "ğŸ” Consultando PR #$PR_NUMBER..."
            status=$(curl -s "https://sonarcloud.io/api/qualitygates/project_status?projectKey=see-paw_backend&pullRequest=$PR_NUMBER" \
              -H "Authorization: Bearer ${{ secrets.SONAR_TOKEN }}" | jq -r '.projectStatus.status')
          fi
          
          echo "ğŸ“Š Status recebido: $status"

          if [ "$status" = "ERROR" ]; then
            echo "âŒ QUALITY GATE FALHOU: SonarCloud Quality Gate"
            exit 1
          elif [ "$status" = "OK" ]; then
            echo "âœ… QUALITY GATE PASSOU: SonarCloud Quality Gate"
          else
            echo "âš ï¸ Status desconhecido: $status"
            echo ""
            echo "ğŸ” Debug - Response completa:"
            curl -s "https://sonarcloud.io/api/qualitygates/project_status?projectKey=see-paw_backend&pullRequest=$PR_NUMBER" \
              -H "Authorization: Bearer ${{ secrets.SONAR_TOKEN }}" | jq '.'
            exit 1
          fi
    # ==========================================
    # QUALITY GATE 4: MÃ©tricas Personalizadas
    # ==========================================
      - name: Quality Gate 4 - Validar MÃ©tricas Personalizadas (SeePaw)
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š QUALITY GATE 4: MÃ‰TRICAS PERSONALIZADAS SEEPAW"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          PR_NUMBER="${{ github.event.pull_request.number }}"

          # Obter mÃ©tricas do SonarCloud (com PR)
          if [ -z "$PR_NUMBER" ]; then
            response=$(curl -s "https://sonarcloud.io/api/measures/component?componentKey=see-paw_backend&metricKeys=coverage,complexity,code_smells,bugs,vulnerabilities" \
              -H "Authorization: Bearer ${{ secrets.SONAR_TOKEN }}")
          else
            response=$(curl -s "https://sonarcloud.io/api/measures/component?componentKey=see-paw_backend&metricKeys=coverage,complexity,code_smells,bugs,vulnerabilities&pullRequest=$PR_NUMBER" \
              -H "Authorization: Bearer ${{ secrets.SONAR_TOKEN }}")
          fi

          coverage=$(echo "$response" | jq -r '.component.measures[] | select(.metric=="coverage") | .value // "0"' | cut -d'.' -f1)
          complexity=$(echo "$response" | jq -r '.component.measures[] | select(.metric=="complexity") | .value // "0"' | cut -d'.' -f1)
          smells=$(echo "$response" | jq -r '.component.measures[] | select(.metric=="code_smells") | .value // "0"' | cut -d'.' -f1)
          bugs=$(echo "$response" | jq -r '.component.measures[] | select(.metric=="bugs") | .value // "0"' | cut -d'.' -f1)
          vulnerabilities=$(echo "$response" | jq -r '.component.measures[] | select(.metric=="vulnerabilities") | .value // "0"' | cut -d'.' -f1)

          # Determinar categoria baseada no tÃ­tulo do PR
          pr_title="${{ github.event.pull_request.title || 'Basic' }}"
          
          category="Basic"
          min_coverage=40
          
          if echo "$pr_title" | grep -iq "intermediate"; then
            category="Intermediate"
            min_coverage=50
          elif echo "$pr_title" | grep -iq "critical"; then
            category="Critical"
            min_coverage=80
          fi
          
          echo "ğŸ“‹ Categoria detectada: $category"
          echo "ğŸ“Š Cobertura mÃ­nima requerida: ${min_coverage}%"
          echo ""
          echo "ğŸ“ˆ MÃ©tricas obtidas:"
          echo "   Cobertura de cÃ³digo: ${coverage}%"
          echo "   Complexidade ciclomÃ¡tica: $complexity"
          echo "   Code Smells: $smells"
          echo "   Bugs: $bugs"
          echo "   Vulnerabilidades: $vulnerabilities"
          echo ""
          
          # ValidaÃ§Ãµes
          failed=0
          
          echo "ğŸ” Validando mÃ©tricas..."
          
          # 1. Cobertura de cÃ³digo
          if [ "$coverage" -lt "$min_coverage" ]; then
            echo "   âŒ Cobertura: ${coverage}% < ${min_coverage}% (mÃ­nimo para $category)"
            failed=1
          else
            echo "   âœ… Cobertura: ${coverage}% >= ${min_coverage}%"
          fi
          
          # 2. Complexidade ciclomÃ¡tica
          if [ "$complexity" -gt 14 ]; then
            echo "   âŒ Complexidade: $complexity > 14 (mÃ¡ximo)"
            failed=1
          else
            echo "   âœ… Complexidade: $complexity <= 14"
          fi
          
          # 3. Bugs crÃ­ticos (erros de compilaÃ§Ã£o/build)
          if [ "$bugs" -gt 0 ]; then
            echo "   âŒ Bugs: $bugs > 0 (mÃ¡ximo)"
            failed=1
          else
            echo "   âœ… Bugs: $bugs = 0"
          fi
          
          # 4. Vulnerabilidades crÃ­ticas
          if [ "$vulnerabilities" -gt 0 ]; then
            echo "   âŒ Vulnerabilidades: $vulnerabilities > 0 (mÃ¡ximo)"
            failed=1
          else
            echo "   âœ… Vulnerabilidades: $vulnerabilities = 0"
          fi
          
          # 5. Code Smells (avisos nÃ£o crÃ­ticos)
          if [ "$smells" -gt 10 ]; then
            echo "   âŒ Code Smells: $smells > 10 (mÃ¡ximo)"
            failed=1
          else
            echo "   âœ… Code Smells: $smells <= 10"
          fi
          
          # Salvar mÃ©tricas em JSON
          jq -n \
            --arg coverage "$coverage" \
            --arg complexity "$complexity" \
            --arg smells "$smells" \
            --arg bugs "$bugs" \
            --arg vulnerabilities "$vulnerabilities" \
            --arg category "$category" \
            --arg min_cov "$min_coverage" \
            '{
              coverage: $coverage,
              complexity: $complexity,
              code_smells: $smells,
              bugs: $bugs,
              vulnerabilities: $vulnerabilities,
              category: $category,
              min_coverage: $min_cov,
              timestamp: (now | todate)
            }' > metrics.json
          
          echo ""
          if [ $failed -eq 1 ]; then
            echo "âŒ QUALITY GATE FALHOU: MÃ©tricas personalizadas nÃ£o atingidas"
            exit 1
          else
            echo "âœ… QUALITY GATE PASSOU: Todas as mÃ©tricas personalizadas atingidas"
          fi

        # ==========================================
      # Resumo Final
      # ==========================================
      - name: Resumo Final dos Quality Gates
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ¯ RESUMO DOS QUALITY GATES"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Quality Gate 1: Testes UnitÃ¡rios"
          echo "âœ… Quality Gate 2: Testes de IntegraÃ§Ã£o"
          echo "âœ… Quality Gate 3: SonarCloud"
          echo "âœ… Quality Gate 4: MÃ©tricas Personalizadas"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ‰ TODOS OS QUALITY GATES PASSARAM!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  
      - name: Guardar artefacto das mÃ©tricas
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-metrics
          path: metrics.json
          
  
